[{"F:\\projects\\blog\\src\\index.js":"1","F:\\projects\\blog\\src\\App.js":"2","F:\\projects\\blog\\src\\reportWebVitals.js":"3","F:\\projects\\blog\\src\\algorithms\\index.js":"4","F:\\projects\\blog\\src\\algorithms\\stack\\index.js":"5","F:\\projects\\blog\\src\\algorithms\\dynamicProgram\\index.js":"6","F:\\projects\\blog\\src\\algorithms\\dynamicProgram\\dp1.js":"7","F:\\projects\\blog\\src\\algorithms\\greedy\\index.js":"8","F:\\projects\\blog\\src\\algorithms\\greedy\\greedy1.js":"9","F:\\projects\\blog\\src\\algorithms\\sort\\index.js":"10","F:\\projects\\blog\\src\\algorithms\\sort\\quickSort.js":"11","F:\\projects\\blog\\src\\algorithms\\sort\\insertSort.js":"12","F:\\projects\\blog\\src\\algorithms\\recursive\\index.js":"13","F:\\projects\\blog\\src\\algorithms\\recursive\\recursive1.js":"14","F:\\projects\\blog\\src\\algorithms\\recursive\\recursive2.js":"15","F:\\projects\\blog\\src\\algorithms\\recursive\\nQueen.js":"16","F:\\projects\\blog\\src\\algorithms\\greedy\\greedy2.js":"17"},{"size":500,"mtime":1611816651046,"results":"18","hashOfConfig":"19"},{"size":334,"mtime":1614923664298,"results":"20","hashOfConfig":"19"},{"size":362,"mtime":1611816651046,"results":"21","hashOfConfig":"19"},{"size":439,"mtime":1615778424494,"results":"22","hashOfConfig":"19"},{"size":1696,"mtime":1615016244051,"results":"23","hashOfConfig":"19"},{"size":387,"mtime":1615432200044,"results":"24","hashOfConfig":"19"},{"size":3446,"mtime":1615027118052,"results":"25","hashOfConfig":"19"},{"size":461,"mtime":1616055197160,"results":"26","hashOfConfig":"19"},{"size":2902,"mtime":1616057644261,"results":"27","hashOfConfig":"19"},{"size":504,"mtime":1615774282744,"results":"28","hashOfConfig":"19"},{"size":1564,"mtime":1615775076472,"results":"29","hashOfConfig":"19"},{"size":1049,"mtime":1615775079151,"results":"30","hashOfConfig":"19"},{"size":526,"mtime":1615792627948,"results":"31","hashOfConfig":"19"},{"size":1489,"mtime":1615790431855,"results":"32","hashOfConfig":"19"},{"size":1899,"mtime":1615791317642,"results":"33","hashOfConfig":"19"},{"size":2755,"mtime":1615796368490,"results":"34","hashOfConfig":"19"},{"size":1512,"mtime":1616055214096,"results":"35","hashOfConfig":"19"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},"1daoe5p",{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"45","usedDeprecatedRules":"38"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"48","usedDeprecatedRules":"38"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"51","usedDeprecatedRules":"38"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"54","usedDeprecatedRules":"38"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"57","messages":"58","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"59","messages":"60","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"61","usedDeprecatedRules":"38"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"64","usedDeprecatedRules":"38"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"67","usedDeprecatedRules":"38"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"70","usedDeprecatedRules":"38"},{"filePath":"71","messages":"72","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"73","usedDeprecatedRules":"38"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"76","usedDeprecatedRules":"38"},{"filePath":"77","messages":"78","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"79","usedDeprecatedRules":"38"},{"filePath":"80","messages":"81","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"F:\\projects\\blog\\src\\index.js",[],["82","83"],"F:\\projects\\blog\\src\\App.js",[],"F:\\projects\\blog\\src\\reportWebVitals.js",[],"F:\\projects\\blog\\src\\algorithms\\index.js",["84","85"],"import { useState, userEffect } from 'react';\r\n// import './style/index.css';\r\nimport Stack from './stack';\r\nimport DP from './dynamicProgram';\r\nimport Greedy from './greedy';\r\nimport Sort from './sort';\r\nimport Recursive from './recursive';\r\n\r\nexport default function Index() {\r\n  return (\r\n    <div>\r\n      <h2>算法专题</h2>\r\n      <Stack />\r\n      <DP />\r\n      <Greedy />\r\n      <Sort />\r\n      <Recursive />\r\n    </div>\r\n  );\r\n}\r\n","F:\\projects\\blog\\src\\algorithms\\stack\\index.js",["86","87"],"// 栈问题\r\n// 有效的括号-20\r\n\r\n// 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。\r\n\r\n// 有效字符串需满足：\r\n\r\n// 左括号必须用相同类型的右括号闭合。\r\n// 左括号必须以正确的顺序闭合。\r\n// 注意空字符串可被认为是有效字符串。\r\n// 示例 1:\r\n\r\n// 输入: \"()\"\r\n// 输出: true\r\n// 示例 2:\r\n\r\n// 输入: \"()[]{}\"\r\n// 输出: true\r\n// 示例 3:\r\n\r\n// 输入: \"(]\"\r\n// 输出: false\r\n// 示例 4:\r\n\r\n// 输入: \"([)]\"\r\n// 输出: false\r\n// 示例 5:\r\n\r\n// 输入: \"{[]}\"\r\n// 输出: true\r\n\r\nimport { useState, userEffect } from 'react';\r\nimport './style/index.css';\r\n\r\nexport default function Index() {\r\n  //   const [showSort, setShowSort] = useState(false);\r\n\r\n  return (\r\n    <div>\r\n      <p\r\n        className=\"hoverClick\"\r\n        onClick={e => {\r\n          const result = runStack('[(]');\r\n          console.log('🚀 ~ file: index.js ~ line 44 ~ Index ~ result', result);\r\n        }}\r\n      >\r\n        Stack栈的算法解析\r\n      </p>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction runStack(str) {\r\n  window.runStack = runStack;\r\n  const leftToRight = {\r\n    '(': ')',\r\n    '[': ']',\r\n    '{': '}',\r\n  };\r\n  const RightToLeft = {\r\n    ')': '(',\r\n    ']': '[',\r\n    '}': '{',\r\n  };\r\n  const stack = [];\r\n  for (let i = 0; i < str.length; i++) {\r\n    if (leftToRight[str[i]]) {\r\n      stack.push(str[i]);\r\n    } else if (RightToLeft[str[i]]) {\r\n      if (RightToLeft[str[i]] !== stack.pop()) return false;\r\n    } else {\r\n      return false;\r\n    }\r\n    console.log('🚀 ~ file: index.js ~ line 69 ~ runStack ~ stack', stack);\r\n  }\r\n  if (stack.length > 0) return false;\r\n  return true;\r\n}\r\n","F:\\projects\\blog\\src\\algorithms\\dynamicProgram\\index.js",["88"],"//  动态规划\r\n\r\nimport { useState, userEffect } from 'react';\r\nimport './style/index.css';\r\nimport DP1 from './dp1';\r\n\r\nexport default function Index() {\r\n  const [show, setShow] = useState(false);\r\n\r\n  return (\r\n    <div>\r\n      <p className=\"hoverClick\" onClick={e => setShow(!show)}>\r\n        动态规划的算法解析\r\n      </p>\r\n      {show && <DP1 />}\r\n    </div>\r\n  );\r\n}\r\n","F:\\projects\\blog\\src\\algorithms\\dynamicProgram\\dp1.js",["89","90","91"],"// 打家劫舍 - 198\r\n\r\n// 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\r\n\r\n// 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。\r\n\r\n// 示例 1:\r\n\r\n// 输入: [1,2,3,1]\r\n// 输出: 4\r\n// 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\r\n//   偷窃到的最高金额 = 1 + 3 = 4 。\r\n// 示例 2:\r\n\r\n// 输入: [2,7,9,3,1]\r\n// 输出: 12\r\n// 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\r\n//   偷窃到的最高金额 = 2 + 9 + 1 = 12 。\r\n\r\n// ----------------------------------------------------------------------------------------------------------------------\r\n\r\n// 动态规划的一个很重要的过程就是找到「状态」和「状态转移方程」，在这个问题里，设 i 是当前屋子的下标，状态就是 以 i 为起点偷窃的最大价值\r\n\r\n// 在某一个房子面前，盗贼只有两种选择：偷或者不偷。\r\n\r\n// 偷的话，价值就是「当前房子的价值」+「下两个房子开始盗窃的最大价值」\r\n// 不偷的话，价值就是「下一个房子开始盗窃的最大价值」\r\n// 在这两个值中，选择最大值记录在 dp[i]中，就得到了以 i 为起点所能偷窃的最大价值。。\r\n\r\n// 动态规划的起手式，找基础状态，在这题中，以终点为起点的最大价值一定是最好找的，因为终点不可能再继续往后偷窃了，所以设 n 为房子的总数量， dp[n - 1] 就是 nums[n - 1]，小偷只能选择偷窃这个房子，而不能跳过去选择下一个不存在的房子。\r\n\r\n// 那么就找到了动态规划的状态转移方程：\r\n// 从头开始往后\r\n// 打劫当前家：num[i] + dp[i-2]\r\n// 不打劫当前家：dp[i-1]\r\n// 转移方程是：dp[i] = max(num[i]+dp[i-2], dp[i-1])\r\n// 返回dp[n-1]\r\n\r\n// 从结尾开始\r\n// 打劫当前家：num[i] + dp[i+2]\r\n// 不打劫当前家：dp[i+1]\r\n// 转移方程是：dp[i] = max(num[i]+dp[i+2], dp[i+1])\r\n// 返回dp[0]\r\n\r\nimport { useState, userEffect } from 'react';\r\nimport './style/index.css';\r\n\r\nexport default function Dp1() {\r\n  //   const [showSort, setShowSort] = useState(false);\r\n\r\n  return (\r\n    <div>\r\n      <p\r\n        className=\"hoverClick subTitle\"\r\n        onClick={e => {\r\n          const result = runFunc([1, 2, 3, 1]);\r\n          // const result = runFunc2([2, 7, 9, 3, 1]);\r\n          console.log('🚀 ~ file: dp1.js ~ line 57 ~ Dp1 ~ result', result);\r\n        }}\r\n      >\r\n        打家劫舍动态规划\r\n      </p>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction runFunc(arr) {\r\n  window.runFunc = runFunc;\r\n  if (arr.length === 0 || !arr) return false;\r\n  const dp = [];\r\n  dp[0] = arr[0];\r\n  dp[1] = Math.max(arr[0], arr[1]);\r\n\r\n  for (let i = 2; i < arr.length; i++) {\r\n    dp[i] = Math.max(arr[i] + dp[i - 2], dp[i - 1]);\r\n  }\r\n  return dp[arr.length - 1];\r\n}\r\n\r\nfunction runFunc2(arr) {\r\n  window.runFunc = runFunc;\r\n  if (arr.length === 0 || !arr) return false;\r\n  const dp = [];\r\n\r\n  for (let i = arr.length - 1; i >= 0; i--) {\r\n    dp[i] = Math.max(arr[i] + (dp[i + 2] || 0), dp[i + 1] || 0);\r\n  }\r\n  return dp[0];\r\n}\r\n","F:\\projects\\blog\\src\\algorithms\\greedy\\index.js",["92"],"F:\\projects\\blog\\src\\algorithms\\greedy\\greedy1.js",["93","94"],"F:\\projects\\blog\\src\\algorithms\\sort\\index.js",["95"],"import { useState, userEffect } from 'react';\r\nimport InsertSortDisplay from './insertSort';\r\nimport QuickSortDisplay from './quickSort';\r\nimport './style/index.css';\r\n\r\nexport default function Index() {\r\n  const [showSort, setShowSort] = useState(false);\r\n  return (\r\n    <div>\r\n      <p className=\"hoverClick\" onClick={e => setShowSort(!showSort)}>\r\n        Array的sort算法解析\r\n      </p>\r\n      {showSort && <InsertSortDisplay />}\r\n      {showSort && <QuickSortDisplay />}\r\n    </div>\r\n  );\r\n}\r\n","F:\\projects\\blog\\src\\algorithms\\sort\\quickSort.js",["96"],"// 阮一峰版快速排序，都理解，都在采用，被人诟病的是用了splice，用了新数组增加了空间成本\r\nlet quickSort = arr => {\r\n  if (arr.length <= 1) return arr;\r\n  let thirdIndex = arr.length >> 1;\r\n  let pivot = arr.splice(thirdIndex, 1)[0];\r\n  let left = [];\r\n  let right = [];\r\n  arr.forEach(item => {\r\n    if (item < pivot) left.push(item);\r\n    else right.push(item);\r\n  });\r\n\r\n  return quickSort(left).concat(pivot, quickSort(right));\r\n};\r\n\r\n// 面试官大干阮一峰 改良版快速排序\r\n\r\n// 以最左端为比较值进行改良版快速排序\r\nlet quickSort2 = (arr, start, end) => {\r\n  if (arr.length <= 1) return arr;\r\n  const devideArr = (array, s, e) => {\r\n    let i = s;\r\n    let j = e;\r\n    let base = array[s];\r\n    while (i < j) {\r\n      while (arr[j] >= base && i < j) j--;\r\n      while (arr[i] <= base && i < j) i++;\r\n      if (i < j) [arr[i], arr[j]] = [arr[j], arr[i]];\r\n    }\r\n    return i;\r\n  };\r\n  const index = devideArr(arr, start, end);\r\n  [arr[start], arr[index]] = [arr[index], arr[start]];\r\n  if (start < index - 1) quickSort2(arr, start, index - 1);\r\n  if (index + 1 < end) quickSort2(arr, index + 1, end);\r\n  return arr;\r\n};\r\n\r\nexport default function quickSortDisplay() {\r\n  const arr = new Array(15).fill(0).map((a, i) => i);\r\n  arr.sort(() => 0.5 - Math.random());\r\n  return (\r\n    <div>\r\n      <p className=\"subTitle\">快速排序展示</p>\r\n      <p className=\"subTitle\">[{String(arr)}]</p>\r\n      <p className=\"subTitle\">[{String(quickSort2(arr, 0, arr.length - 1))}]</p>\r\n    </div>\r\n  );\r\n}\r\n","F:\\projects\\blog\\src\\algorithms\\sort\\insertSort.js",["97","98","99"],"import { userState, userEffect } from 'react';\r\n\r\n// 最初的插入排序\r\nconst insertSort = (arr, start, end) => {\r\n  end = end || arr.length;\r\n  for (let i = start; i < end; i++) {\r\n    for (let j = i; j > start && arr[j - 1] > arr[j]; j--) {\r\n      [arr[j - 1], arr[j]] = [arr[j], arr[j - 1]];\r\n    }\r\n  }\r\n  return arr;\r\n};\r\n\r\n// 优化后的插入排序 不需要每次交换\r\nconst insertSortBetter = (arr, start, end) => {\r\n  end = end || arr.length;\r\n  for (let i = start; i < end; i++) {\r\n    let tmp = arr[i];\r\n    let j = 0;\r\n    for (j = i; j > start && arr[j - 1] > tmp; j--) {\r\n      arr[j] = arr[j - 1];\r\n    }\r\n    arr[j] = tmp;\r\n  }\r\n  return arr;\r\n};\r\n\r\nexport default function insertSortDisplay() {\r\n  const arr = new Array(15).fill(0).map((a, i) => i);\r\n  arr.sort(() => 0.5 - Math.random());\r\n  return (\r\n    <div>\r\n      <p className=\"subTitle\">插入排序展示</p>\r\n      <p className=\"subTitle\">[{String(arr)}]</p>\r\n      <p className=\"subTitle\">[{String(insertSortBetter(arr, 0, arr.length))}]</p>\r\n    </div>\r\n  );\r\n}\r\n","F:\\projects\\blog\\src\\algorithms\\recursive\\index.js",["100"],"import { useState, userEffect } from 'react';\r\nimport './style/index.css';\r\nimport Recursive1 from './recursive1';\r\nimport Recursive2 from './recursive2';\r\nimport NQueen from './nQueen';\r\n\r\nexport default function Index() {\r\n  const [show, setShow] = useState(false);\r\n\r\n  return (\r\n    <div>\r\n      <p className=\"hoverClick\" onClick={e => setShow(!show)}>\r\n        递归回溯算法的算法解析\r\n      </p>\r\n      {show && <Recursive1 />}\r\n      {show && <Recursive2 />}\r\n      {show && <NQueen />}\r\n    </div>\r\n  );\r\n}\r\n","F:\\projects\\blog\\src\\algorithms\\recursive\\recursive1.js",["101","102"],"//  递归回溯算法问题解析\r\n// 组合-77\r\n// 77. 组合 这是一道难度为 medium 的问题，其实算是比较有难度的问题了：\r\n// 问题\r\n// 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。\r\n// 示例:\r\n// 输入: n = 4, k = 2\r\n// 输出:\r\n// [\r\n//   [2,4],\r\n//   [3,4],\r\n//   [2,3],\r\n//   [1,2],\r\n//   [1,3],\r\n//   [1,4],\r\n// ]\r\n\r\nimport { useState, userEffect } from 'react';\r\nimport './style/index.css';\r\n\r\nexport default function Recursive1() {\r\n  //   const [showSort, setShowSort] = useState(false);\r\n\r\n  return (\r\n    <div>\r\n      <p\r\n        className=\"hoverClick subTitle\"\r\n        onClick={e => {\r\n          //   const result = runFunc([1, 2], [1, 2, 3]);\r\n          const result = runFunc(4, 3);\r\n          console.log('🚀 ~ file: recursive1.js ~ line 16 ~ Greedy1 ~ result', result);\r\n        }}\r\n      >\r\n        组合问题 递归回溯算法\r\n      </p>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction runFunc(n, k) {\r\n  window.runFunc = runFunc;\r\n  const result = [];\r\n  function runInnerFunc(start, prevArr) {\r\n    const length = prevArr.length;\r\n    if (length === k) {\r\n      result.push(prevArr);\r\n      return;\r\n    } else {\r\n      // const restLen = k - prevArr.length; // 剪枝过程\r\n      for (let i = start; i <= n; i++) {\r\n        // if (n - i + 1 < restLen) {\r\n        //   continue;\r\n        // }\r\n        runInnerFunc(i + 1, prevArr.concat(i));\r\n      }\r\n    }\r\n  }\r\n  runInnerFunc(1, []);\r\n  return result;\r\n}\r\n","F:\\projects\\blog\\src\\algorithms\\recursive\\recursive2.js",["103","104"],"//  递归回溯算法问题解析\r\n// 前端电商 sku 的全排列算法\r\n// 需求\r\n// 需求描述起来很简单，有这样三个数组：\r\n// let names = [\"iPhone X\", \"iPhone XS\"]\r\n\r\n// let colors = [\"黑色\", \"白色\"]\r\n\r\n// let storages = [\"64g\", \"256g\"]\r\n// 需要把他们的所有组合穷举出来，最终得到这样一个数组：\r\n// [\r\n//   [\"iPhone X\", \"黑色\", \"64g\"],\r\n//   [\"iPhone X\", \"黑色\", \"256g\"],\r\n//   [\"iPhone X\", \"白色\", \"64g\"],\r\n//   [\"iPhone X\", \"白色\", \"256g\"],\r\n//   [\"iPhone XS\", \"黑色\", \"64g\"],\r\n//   [\"iPhone XS\", \"黑色\", \"256g\"],\r\n//   [\"iPhone XS\", \"白色\", \"64g\"],\r\n//   [\"iPhone XS\", \"白色\", \"256g\"],\r\n// ]\r\n\r\nimport { useState, userEffect } from 'react';\r\nimport './style/index.css';\r\n\r\nexport default function Recursive2() {\r\n  //   const [showSort, setShowSort] = useState(false);\r\n  let names = ['iPhone X', 'iPhone XS'];\r\n\r\n  let colors = ['黑色', '白色'];\r\n\r\n  let storages = ['64g', '256g'];\r\n  // let size = ['6寸', '8寸', '10寸', '12寸'];\r\n  return (\r\n    <div>\r\n      <p\r\n        className=\"hoverClick subTitle\"\r\n        onClick={e => {\r\n          //   const result = runFunc([1, 2], [1, 2, 3]);\r\n          const result = runFunc(names, colors, storages);\r\n          console.log('🚀 ~ file: recursive2.js ~ line 40 ~ Recursive2 ~ result', result);\r\n        }}\r\n      >\r\n        前端电商 sku 的全排列算法 递归回溯算法\r\n      </p>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction runFunc(...args) {\r\n  window.runFunc = runFunc;\r\n  const result = [];\r\n  const length = args.length;\r\n\r\n  function runInnerFunc(start, prev) {\r\n    if (prev.length === length) {\r\n      result.push(prev);\r\n      return;\r\n    } else {\r\n      const thisArr = args[start];\r\n      for (let i = 0; i < thisArr.length; i++) {\r\n        runInnerFunc(start + 1, prev.concat(thisArr[i]));\r\n      }\r\n    }\r\n  }\r\n  runInnerFunc(0, []);\r\n  return result;\r\n}\r\n","F:\\projects\\blog\\src\\algorithms\\recursive\\nQueen.js",["105","106"],"//  递归回溯算法问题解析\r\n// n皇后问题\r\n// 问题\r\n// 先来看问题，其实问题不难理解：\r\n// n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\r\n\r\n// 上图为 8 皇后问题的一种解法。\r\n// 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。\r\n// 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。\r\n// 示例:\r\n// 输入: 4\r\n// 输出: [\r\n//  [\".Q..\",  // 解法 1\r\n//   \"...Q\",\r\n//   \"Q...\",\r\n//   \"..Q.\"],\r\n\r\n//  [\"..Q.\",  // 解法 2\r\n//   \"Q...\",\r\n//   \"...Q\",\r\n//   \".Q..\"]\r\n// ]\r\n// 解释: 4 皇后问题存在两个不同的解法。\r\n// 复制代码提示：\r\n\r\n// 皇后，是国际象棋中的棋子，意味着国王的妻子。皇后只做一件事，那就是“吃子”。当她遇见可以吃的棋子时，就迅速冲上去吃掉棋子。当然，她横、竖、斜都可走一到七步，可进可退。（引用自 百度百科 - 皇后 ）\r\n\r\nimport { useState, userEffect } from 'react';\r\nimport './style/index.css';\r\n\r\nexport default function nQueen() {\r\n  //   const [showSort, setShowSort] = useState(false);\r\n  return (\r\n    <div>\r\n      <p\r\n        className=\"hoverClick subTitle\"\r\n        onClick={e => {\r\n          //   const result = runFunc([1, 2], [1, 2, 3]);\r\n          const result = runFunc(4);\r\n          console.log('🚀 ~ file: nQueen.js ~ line 16 ~ Recursive2 ~ result', result);\r\n        }}\r\n      >\r\n        n皇后问题 递归回溯算法\r\n      </p>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction runFunc(n) {\r\n  window.runFunc = runFunc;\r\n  const result = [];\r\n  const columns = [];\r\n  const leftArc = [];\r\n  const rightArc = [];\r\n\r\n  function makeTable(arr) {\r\n    const res = [];\r\n    for (let i = 0; i < n; i++) {\r\n      let row = '';\r\n      for (let j = 0; j < n; j++) {\r\n        if (j === arr[i]) row += 'Q';\r\n        else row += '.';\r\n      }\r\n      res.push(row);\r\n    }\r\n    return res;\r\n  }\r\n\r\n  function placeItem(row, column, bool) {\r\n    columns[column] = bool;\r\n    leftArc[row + column] = bool;\r\n    rightArc[row - column] = bool;\r\n  }\r\n\r\n  function check(row, column) {\r\n    return !columns[column] && !leftArc[row + column] && !rightArc[row - column];\r\n  }\r\n\r\n  function runInnerFunc(start, prev) {\r\n    if (prev.length === n) {\r\n      result.push(makeTable(prev));\r\n      return;\r\n    } else {\r\n      for (let i = 0; i < n; i++) {\r\n        const isOk = check(start, i);\r\n        if (!isOk) continue;\r\n        placeItem(start, i, true);\r\n        runInnerFunc(start + 1, prev.concat(i));\r\n        placeItem(start, i, false);\r\n      }\r\n    }\r\n  }\r\n  runInnerFunc(0, []);\r\n  return result;\r\n}\r\n","F:\\projects\\blog\\src\\algorithms\\greedy\\greedy2.js",["107","108"],{"ruleId":"109","replacedBy":"110"},{"ruleId":"111","replacedBy":"112"},{"ruleId":"113","severity":1,"message":"114","line":1,"column":10,"nodeType":"115","messageId":"116","endLine":1,"endColumn":18},{"ruleId":"113","severity":1,"message":"117","line":1,"column":20,"nodeType":"115","messageId":"116","endLine":1,"endColumn":30},{"ruleId":"113","severity":1,"message":"114","line":32,"column":10,"nodeType":"115","messageId":"116","endLine":32,"endColumn":18},{"ruleId":"113","severity":1,"message":"117","line":32,"column":20,"nodeType":"115","messageId":"116","endLine":32,"endColumn":30},{"ruleId":"113","severity":1,"message":"117","line":3,"column":20,"nodeType":"115","messageId":"116","endLine":3,"endColumn":30},{"ruleId":"113","severity":1,"message":"114","line":45,"column":10,"nodeType":"115","messageId":"116","endLine":45,"endColumn":18},{"ruleId":"113","severity":1,"message":"117","line":45,"column":20,"nodeType":"115","messageId":"116","endLine":45,"endColumn":30},{"ruleId":"113","severity":1,"message":"118","line":80,"column":10,"nodeType":"115","messageId":"116","endLine":80,"endColumn":18},{"ruleId":"113","severity":1,"message":"117","line":3,"column":20,"nodeType":"115","messageId":"116","endLine":3,"endColumn":30},{"ruleId":"113","severity":1,"message":"114","line":41,"column":10,"nodeType":"115","messageId":"116","endLine":41,"endColumn":18},{"ruleId":"113","severity":1,"message":"117","line":41,"column":20,"nodeType":"115","messageId":"116","endLine":41,"endColumn":30},{"ruleId":"113","severity":1,"message":"117","line":1,"column":20,"nodeType":"115","messageId":"116","endLine":1,"endColumn":30},{"ruleId":"113","severity":1,"message":"119","line":13,"column":40,"nodeType":"115","messageId":"116","endLine":13,"endColumn":49},{"ruleId":"113","severity":1,"message":"120","line":1,"column":10,"nodeType":"115","messageId":"116","endLine":1,"endColumn":19},{"ruleId":"113","severity":1,"message":"117","line":1,"column":21,"nodeType":"115","messageId":"116","endLine":1,"endColumn":31},{"ruleId":"113","severity":1,"message":"121","line":4,"column":7,"nodeType":"115","messageId":"116","endLine":4,"endColumn":17},{"ruleId":"113","severity":1,"message":"117","line":1,"column":20,"nodeType":"115","messageId":"116","endLine":1,"endColumn":30},{"ruleId":"113","severity":1,"message":"114","line":18,"column":10,"nodeType":"115","messageId":"116","endLine":18,"endColumn":18},{"ruleId":"113","severity":1,"message":"117","line":18,"column":20,"nodeType":"115","messageId":"116","endLine":18,"endColumn":30},{"ruleId":"113","severity":1,"message":"114","line":22,"column":10,"nodeType":"115","messageId":"116","endLine":22,"endColumn":18},{"ruleId":"113","severity":1,"message":"117","line":22,"column":20,"nodeType":"115","messageId":"116","endLine":22,"endColumn":30},{"ruleId":"113","severity":1,"message":"114","line":28,"column":10,"nodeType":"115","messageId":"116","endLine":28,"endColumn":18},{"ruleId":"113","severity":1,"message":"117","line":28,"column":20,"nodeType":"115","messageId":"116","endLine":28,"endColumn":30},{"ruleId":"113","severity":1,"message":"114","line":13,"column":10,"nodeType":"115","messageId":"116","endLine":13,"endColumn":18},{"ruleId":"113","severity":1,"message":"117","line":13,"column":20,"nodeType":"115","messageId":"116","endLine":13,"endColumn":30},"no-native-reassign",["122"],"no-negated-in-lhs",["123"],"no-unused-vars","'useState' is defined but never used.","Identifier","unusedVar","'userEffect' is defined but never used.","'runFunc2' is defined but never used.","'quickSort' is assigned a value but never used.","'userState' is defined but never used.","'insertSort' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]