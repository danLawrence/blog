[{"F:\\projects\\blog\\src\\index.js":"1","F:\\projects\\blog\\src\\App.js":"2","F:\\projects\\blog\\src\\reportWebVitals.js":"3","F:\\projects\\blog\\src\\algorithms\\index.js":"4","F:\\projects\\blog\\src\\algorithms\\stack\\index.js":"5","F:\\projects\\blog\\src\\algorithms\\dynamicProgram\\index.js":"6","F:\\projects\\blog\\src\\algorithms\\dynamicProgram\\dp1.js":"7","F:\\projects\\blog\\src\\algorithms\\greedy\\index.js":"8","F:\\projects\\blog\\src\\algorithms\\greedy\\greedy1.js":"9","F:\\projects\\blog\\src\\algorithms\\sort\\index.js":"10","F:\\projects\\blog\\src\\algorithms\\sort\\quickSort.js":"11","F:\\projects\\blog\\src\\algorithms\\sort\\insertSort.js":"12","F:\\projects\\blog\\src\\algorithms\\recursive\\index.js":"13","F:\\projects\\blog\\src\\algorithms\\recursive\\recursive1.js":"14","F:\\projects\\blog\\src\\algorithms\\recursive\\recursive2.js":"15","F:\\projects\\blog\\src\\algorithms\\recursive\\nQueen.js":"16","F:\\projects\\blog\\src\\algorithms\\greedy\\greedy2.js":"17","F:\\projects\\blog\\src\\algorithms\\map\\index.js":"18","F:\\projects\\blog\\src\\algorithms\\map\\map1.js":"19"},{"size":500,"mtime":1611816651046,"results":"20","hashOfConfig":"21"},{"size":334,"mtime":1614923664298,"results":"22","hashOfConfig":"21"},{"size":362,"mtime":1611816651046,"results":"23","hashOfConfig":"21"},{"size":474,"mtime":1617157939136,"results":"24","hashOfConfig":"21"},{"size":1696,"mtime":1615016244051,"results":"25","hashOfConfig":"21"},{"size":387,"mtime":1615432200044,"results":"26","hashOfConfig":"21"},{"size":3446,"mtime":1615027118052,"results":"27","hashOfConfig":"21"},{"size":461,"mtime":1616055197160,"results":"28","hashOfConfig":"21"},{"size":2902,"mtime":1616057644261,"results":"29","hashOfConfig":"21"},{"size":504,"mtime":1615774282744,"results":"30","hashOfConfig":"21"},{"size":1564,"mtime":1615775076472,"results":"31","hashOfConfig":"21"},{"size":1049,"mtime":1615775079151,"results":"32","hashOfConfig":"21"},{"size":526,"mtime":1615792627948,"results":"33","hashOfConfig":"21"},{"size":1489,"mtime":1615790431855,"results":"34","hashOfConfig":"21"},{"size":1899,"mtime":1615791317642,"results":"35","hashOfConfig":"21"},{"size":2755,"mtime":1615796368490,"results":"36","hashOfConfig":"21"},{"size":1512,"mtime":1616055214096,"results":"37","hashOfConfig":"21"},{"size":392,"mtime":1617157061782,"results":"38","hashOfConfig":"21"},{"size":1278,"mtime":1617184822222,"results":"39","hashOfConfig":"21"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},"1daoe5p",{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"49","messages":"50","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"51","usedDeprecatedRules":"42"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"54","usedDeprecatedRules":"42"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"57","usedDeprecatedRules":"42"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"60","usedDeprecatedRules":"42"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"63","usedDeprecatedRules":"42"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"66","usedDeprecatedRules":"42"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"69","usedDeprecatedRules":"42"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"72","usedDeprecatedRules":"42"},{"filePath":"73","messages":"74","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"75","usedDeprecatedRules":"42"},{"filePath":"76","messages":"77","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"78","usedDeprecatedRules":"42"},{"filePath":"79","messages":"80","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"81","usedDeprecatedRules":"42"},{"filePath":"82","messages":"83","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"84","usedDeprecatedRules":"42"},{"filePath":"85","messages":"86","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"87","usedDeprecatedRules":"42"},{"filePath":"88","messages":"89","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"90","messages":"91","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"F:\\projects\\blog\\src\\index.js",[],["92","93"],"F:\\projects\\blog\\src\\App.js",[],"F:\\projects\\blog\\src\\reportWebVitals.js",[],"F:\\projects\\blog\\src\\algorithms\\index.js",["94","95"],"F:\\projects\\blog\\src\\algorithms\\stack\\index.js",["96","97"],"// 栈问题\r\n// 有效的括号-20\r\n\r\n// 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。\r\n\r\n// 有效字符串需满足：\r\n\r\n// 左括号必须用相同类型的右括号闭合。\r\n// 左括号必须以正确的顺序闭合。\r\n// 注意空字符串可被认为是有效字符串。\r\n// 示例 1:\r\n\r\n// 输入: \"()\"\r\n// 输出: true\r\n// 示例 2:\r\n\r\n// 输入: \"()[]{}\"\r\n// 输出: true\r\n// 示例 3:\r\n\r\n// 输入: \"(]\"\r\n// 输出: false\r\n// 示例 4:\r\n\r\n// 输入: \"([)]\"\r\n// 输出: false\r\n// 示例 5:\r\n\r\n// 输入: \"{[]}\"\r\n// 输出: true\r\n\r\nimport { useState, userEffect } from 'react';\r\nimport './style/index.css';\r\n\r\nexport default function Index() {\r\n  //   const [showSort, setShowSort] = useState(false);\r\n\r\n  return (\r\n    <div>\r\n      <p\r\n        className=\"hoverClick\"\r\n        onClick={e => {\r\n          const result = runStack('[(]');\r\n          console.log('🚀 ~ file: index.js ~ line 44 ~ Index ~ result', result);\r\n        }}\r\n      >\r\n        Stack栈的算法解析\r\n      </p>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction runStack(str) {\r\n  window.runStack = runStack;\r\n  const leftToRight = {\r\n    '(': ')',\r\n    '[': ']',\r\n    '{': '}',\r\n  };\r\n  const RightToLeft = {\r\n    ')': '(',\r\n    ']': '[',\r\n    '}': '{',\r\n  };\r\n  const stack = [];\r\n  for (let i = 0; i < str.length; i++) {\r\n    if (leftToRight[str[i]]) {\r\n      stack.push(str[i]);\r\n    } else if (RightToLeft[str[i]]) {\r\n      if (RightToLeft[str[i]] !== stack.pop()) return false;\r\n    } else {\r\n      return false;\r\n    }\r\n    console.log('🚀 ~ file: index.js ~ line 69 ~ runStack ~ stack', stack);\r\n  }\r\n  if (stack.length > 0) return false;\r\n  return true;\r\n}\r\n","F:\\projects\\blog\\src\\algorithms\\dynamicProgram\\index.js",["98"],"//  动态规划\r\n\r\nimport { useState, userEffect } from 'react';\r\nimport './style/index.css';\r\nimport DP1 from './dp1';\r\n\r\nexport default function Index() {\r\n  const [show, setShow] = useState(false);\r\n\r\n  return (\r\n    <div>\r\n      <p className=\"hoverClick\" onClick={e => setShow(!show)}>\r\n        动态规划的算法解析\r\n      </p>\r\n      {show && <DP1 />}\r\n    </div>\r\n  );\r\n}\r\n","F:\\projects\\blog\\src\\algorithms\\dynamicProgram\\dp1.js",["99","100","101"],"// 打家劫舍 - 198\r\n\r\n// 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\r\n\r\n// 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。\r\n\r\n// 示例 1:\r\n\r\n// 输入: [1,2,3,1]\r\n// 输出: 4\r\n// 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\r\n//   偷窃到的最高金额 = 1 + 3 = 4 。\r\n// 示例 2:\r\n\r\n// 输入: [2,7,9,3,1]\r\n// 输出: 12\r\n// 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\r\n//   偷窃到的最高金额 = 2 + 9 + 1 = 12 。\r\n\r\n// ----------------------------------------------------------------------------------------------------------------------\r\n\r\n// 动态规划的一个很重要的过程就是找到「状态」和「状态转移方程」，在这个问题里，设 i 是当前屋子的下标，状态就是 以 i 为起点偷窃的最大价值\r\n\r\n// 在某一个房子面前，盗贼只有两种选择：偷或者不偷。\r\n\r\n// 偷的话，价值就是「当前房子的价值」+「下两个房子开始盗窃的最大价值」\r\n// 不偷的话，价值就是「下一个房子开始盗窃的最大价值」\r\n// 在这两个值中，选择最大值记录在 dp[i]中，就得到了以 i 为起点所能偷窃的最大价值。。\r\n\r\n// 动态规划的起手式，找基础状态，在这题中，以终点为起点的最大价值一定是最好找的，因为终点不可能再继续往后偷窃了，所以设 n 为房子的总数量， dp[n - 1] 就是 nums[n - 1]，小偷只能选择偷窃这个房子，而不能跳过去选择下一个不存在的房子。\r\n\r\n// 那么就找到了动态规划的状态转移方程：\r\n// 从头开始往后\r\n// 打劫当前家：num[i] + dp[i-2]\r\n// 不打劫当前家：dp[i-1]\r\n// 转移方程是：dp[i] = max(num[i]+dp[i-2], dp[i-1])\r\n// 返回dp[n-1]\r\n\r\n// 从结尾开始\r\n// 打劫当前家：num[i] + dp[i+2]\r\n// 不打劫当前家：dp[i+1]\r\n// 转移方程是：dp[i] = max(num[i]+dp[i+2], dp[i+1])\r\n// 返回dp[0]\r\n\r\nimport { useState, userEffect } from 'react';\r\nimport './style/index.css';\r\n\r\nexport default function Dp1() {\r\n  //   const [showSort, setShowSort] = useState(false);\r\n\r\n  return (\r\n    <div>\r\n      <p\r\n        className=\"hoverClick subTitle\"\r\n        onClick={e => {\r\n          const result = runFunc([1, 2, 3, 1]);\r\n          // const result = runFunc2([2, 7, 9, 3, 1]);\r\n          console.log('🚀 ~ file: dp1.js ~ line 57 ~ Dp1 ~ result', result);\r\n        }}\r\n      >\r\n        打家劫舍动态规划\r\n      </p>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction runFunc(arr) {\r\n  window.runFunc = runFunc;\r\n  if (arr.length === 0 || !arr) return false;\r\n  const dp = [];\r\n  dp[0] = arr[0];\r\n  dp[1] = Math.max(arr[0], arr[1]);\r\n\r\n  for (let i = 2; i < arr.length; i++) {\r\n    dp[i] = Math.max(arr[i] + dp[i - 2], dp[i - 1]);\r\n  }\r\n  return dp[arr.length - 1];\r\n}\r\n\r\nfunction runFunc2(arr) {\r\n  window.runFunc = runFunc;\r\n  if (arr.length === 0 || !arr) return false;\r\n  const dp = [];\r\n\r\n  for (let i = arr.length - 1; i >= 0; i--) {\r\n    dp[i] = Math.max(arr[i] + (dp[i + 2] || 0), dp[i + 1] || 0);\r\n  }\r\n  return dp[0];\r\n}\r\n","F:\\projects\\blog\\src\\algorithms\\greedy\\index.js",["102"],"// 贪心算法\r\n\r\nimport { useState, userEffect } from 'react';\r\nimport './style/index.css';\r\nimport Greedy1 from './greedy1';\r\nimport Greedy2 from './greedy2';\r\n\r\nexport default function Index() {\r\n  const [show, setShow] = useState(false);\r\n\r\n  return (\r\n    <div>\r\n      <p className=\"hoverClick\" onClick={e => setShow(!show)}>\r\n        贪心算法的算法解析\r\n      </p>\r\n      {show && <Greedy1 />}\r\n      {show && <Greedy2 />}\r\n    </div>\r\n  );\r\n}\r\n","F:\\projects\\blog\\src\\algorithms\\greedy\\greedy1.js",["103","104"],"// 贪心算法问题\r\n// 分发饼干-455\r\n\r\n// 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值  gi ，\r\n// 这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，\r\n// 这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\r\n\r\n// 注意：\r\n\r\n// 你可以假设胃口值为正。\r\n// 一个小朋友最多只能拥有一块饼干。\r\n\r\n// 示例 1:\r\n\r\n// 输入: [1,2,3], [1,1]\r\n\r\n// 输出: 1\r\n\r\n// 解释:\r\n// 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。\r\n// 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。\r\n// 所以你应该输出1。\r\n// 示例 2:\r\n\r\n// 输入: [1,2], [1,2,3]\r\n\r\n// 输出: 2\r\n\r\n// 解释:\r\n// 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。\r\n// 你拥有的饼干数量和尺寸都足以让所有孩子满足。\r\n// 所以你应该输出2.\r\n\r\n// 把饼干和孩子的需求都排序好，然后从最小的饼干分配给需求最小的孩子开始，不断的尝试新的饼干和新的孩子，这样能保证每个分给孩子的饼干都恰到好处的不浪费，又满足需求。\r\n\r\n// 利用双指针不断的更新 i 孩子的需求下标和 j饼干的值，直到两者有其一达到了终点位置：\r\n\r\n// 如果当前的饼干不满足孩子的胃口，那么把 j++ 寻找下一个饼干，不用担心这个饼干被浪费，因为这个饼干更不可能满足下一个孩子（胃口更大）。\r\n// 如果满足，那么 i++; j++; count++ 记录当前的成功数量，继续寻找下一个孩子和下一个饼干。\r\n\r\nimport { useState, userEffect } from 'react';\r\nimport './style/index.css';\r\n\r\nexport default function Greedy1() {\r\n  //   const [showSort, setShowSort] = useState(false);\r\n\r\n  return (\r\n    <div>\r\n      <p\r\n        className=\"hoverClick subTitle\"\r\n        onClick={e => {\r\n          const result = runFunc([1, 2], [1, 2, 3]);\r\n          // const result = runFunc([1, 2, 3], [1, 1]);\r\n          console.log('🚀 ~ file: greedy1.js ~ line 53 ~ Greedy1 ~ result', result);\r\n        }}\r\n      >\r\n        分发饼干贪心算法\r\n      </p>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction runFunc(arrKid, arrCookie) {\r\n  window.runFunc = runFunc;\r\n  if (!arrKid || !arrCookie) return;\r\n  if (arrKid.length === 0 || arrCookie.length === 0) return 0;\r\n  arrKid.sort();\r\n  arrCookie.sort();\r\n  let count = 0;\r\n  let i = 0;\r\n  let j = 0;\r\n  while (i < arrKid.length && j < arrCookie.length) {\r\n    if (arrCookie[j] >= arrKid[i]) {\r\n      count++;\r\n      i++;\r\n      j++;\r\n    } else {\r\n      j++;\r\n    }\r\n  }\r\n  return count;\r\n}\r\n","F:\\projects\\blog\\src\\algorithms\\sort\\index.js",["105"],"import { useState, userEffect } from 'react';\r\nimport InsertSortDisplay from './insertSort';\r\nimport QuickSortDisplay from './quickSort';\r\nimport './style/index.css';\r\n\r\nexport default function Index() {\r\n  const [showSort, setShowSort] = useState(false);\r\n  return (\r\n    <div>\r\n      <p className=\"hoverClick\" onClick={e => setShowSort(!showSort)}>\r\n        Array的sort算法解析\r\n      </p>\r\n      {showSort && <InsertSortDisplay />}\r\n      {showSort && <QuickSortDisplay />}\r\n    </div>\r\n  );\r\n}\r\n","F:\\projects\\blog\\src\\algorithms\\sort\\quickSort.js",["106"],"// 阮一峰版快速排序，都理解，都在采用，被人诟病的是用了splice，用了新数组增加了空间成本\r\nlet quickSort = arr => {\r\n  if (arr.length <= 1) return arr;\r\n  let thirdIndex = arr.length >> 1;\r\n  let pivot = arr.splice(thirdIndex, 1)[0];\r\n  let left = [];\r\n  let right = [];\r\n  arr.forEach(item => {\r\n    if (item < pivot) left.push(item);\r\n    else right.push(item);\r\n  });\r\n\r\n  return quickSort(left).concat(pivot, quickSort(right));\r\n};\r\n\r\n// 面试官大干阮一峰 改良版快速排序\r\n\r\n// 以最左端为比较值进行改良版快速排序\r\nlet quickSort2 = (arr, start, end) => {\r\n  if (arr.length <= 1) return arr;\r\n  const devideArr = (array, s, e) => {\r\n    let i = s;\r\n    let j = e;\r\n    let base = array[s];\r\n    while (i < j) {\r\n      while (arr[j] >= base && i < j) j--;\r\n      while (arr[i] <= base && i < j) i++;\r\n      if (i < j) [arr[i], arr[j]] = [arr[j], arr[i]];\r\n    }\r\n    return i;\r\n  };\r\n  const index = devideArr(arr, start, end);\r\n  [arr[start], arr[index]] = [arr[index], arr[start]];\r\n  if (start < index - 1) quickSort2(arr, start, index - 1);\r\n  if (index + 1 < end) quickSort2(arr, index + 1, end);\r\n  return arr;\r\n};\r\n\r\nexport default function quickSortDisplay() {\r\n  const arr = new Array(15).fill(0).map((a, i) => i);\r\n  arr.sort(() => 0.5 - Math.random());\r\n  return (\r\n    <div>\r\n      <p className=\"subTitle\">快速排序展示</p>\r\n      <p className=\"subTitle\">[{String(arr)}]</p>\r\n      <p className=\"subTitle\">[{String(quickSort2(arr, 0, arr.length - 1))}]</p>\r\n    </div>\r\n  );\r\n}\r\n","F:\\projects\\blog\\src\\algorithms\\sort\\insertSort.js",["107","108","109"],"import { userState, userEffect } from 'react';\r\n\r\n// 最初的插入排序\r\nconst insertSort = (arr, start, end) => {\r\n  end = end || arr.length;\r\n  for (let i = start; i < end; i++) {\r\n    for (let j = i; j > start && arr[j - 1] > arr[j]; j--) {\r\n      [arr[j - 1], arr[j]] = [arr[j], arr[j - 1]];\r\n    }\r\n  }\r\n  return arr;\r\n};\r\n\r\n// 优化后的插入排序 不需要每次交换\r\nconst insertSortBetter = (arr, start, end) => {\r\n  end = end || arr.length;\r\n  for (let i = start; i < end; i++) {\r\n    let tmp = arr[i];\r\n    let j = 0;\r\n    for (j = i; j > start && arr[j - 1] > tmp; j--) {\r\n      arr[j] = arr[j - 1];\r\n    }\r\n    arr[j] = tmp;\r\n  }\r\n  return arr;\r\n};\r\n\r\nexport default function insertSortDisplay() {\r\n  const arr = new Array(15).fill(0).map((a, i) => i);\r\n  arr.sort(() => 0.5 - Math.random());\r\n  return (\r\n    <div>\r\n      <p className=\"subTitle\">插入排序展示</p>\r\n      <p className=\"subTitle\">[{String(arr)}]</p>\r\n      <p className=\"subTitle\">[{String(insertSortBetter(arr, 0, arr.length))}]</p>\r\n    </div>\r\n  );\r\n}\r\n","F:\\projects\\blog\\src\\algorithms\\recursive\\index.js",["110"],"import { useState, userEffect } from 'react';\r\nimport './style/index.css';\r\nimport Recursive1 from './recursive1';\r\nimport Recursive2 from './recursive2';\r\nimport NQueen from './nQueen';\r\n\r\nexport default function Index() {\r\n  const [show, setShow] = useState(false);\r\n\r\n  return (\r\n    <div>\r\n      <p className=\"hoverClick\" onClick={e => setShow(!show)}>\r\n        递归回溯算法的算法解析\r\n      </p>\r\n      {show && <Recursive1 />}\r\n      {show && <Recursive2 />}\r\n      {show && <NQueen />}\r\n    </div>\r\n  );\r\n}\r\n","F:\\projects\\blog\\src\\algorithms\\recursive\\recursive1.js",["111","112"],"//  递归回溯算法问题解析\r\n// 组合-77\r\n// 77. 组合 这是一道难度为 medium 的问题，其实算是比较有难度的问题了：\r\n// 问题\r\n// 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。\r\n// 示例:\r\n// 输入: n = 4, k = 2\r\n// 输出:\r\n// [\r\n//   [2,4],\r\n//   [3,4],\r\n//   [2,3],\r\n//   [1,2],\r\n//   [1,3],\r\n//   [1,4],\r\n// ]\r\n\r\nimport { useState, userEffect } from 'react';\r\nimport './style/index.css';\r\n\r\nexport default function Recursive1() {\r\n  //   const [showSort, setShowSort] = useState(false);\r\n\r\n  return (\r\n    <div>\r\n      <p\r\n        className=\"hoverClick subTitle\"\r\n        onClick={e => {\r\n          //   const result = runFunc([1, 2], [1, 2, 3]);\r\n          const result = runFunc(4, 3);\r\n          console.log('🚀 ~ file: recursive1.js ~ line 16 ~ Greedy1 ~ result', result);\r\n        }}\r\n      >\r\n        组合问题 递归回溯算法\r\n      </p>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction runFunc(n, k) {\r\n  window.runFunc = runFunc;\r\n  const result = [];\r\n  function runInnerFunc(start, prevArr) {\r\n    const length = prevArr.length;\r\n    if (length === k) {\r\n      result.push(prevArr);\r\n      return;\r\n    } else {\r\n      // const restLen = k - prevArr.length; // 剪枝过程\r\n      for (let i = start; i <= n; i++) {\r\n        // if (n - i + 1 < restLen) {\r\n        //   continue;\r\n        // }\r\n        runInnerFunc(i + 1, prevArr.concat(i));\r\n      }\r\n    }\r\n  }\r\n  runInnerFunc(1, []);\r\n  return result;\r\n}\r\n","F:\\projects\\blog\\src\\algorithms\\recursive\\recursive2.js",["113","114"],"//  递归回溯算法问题解析\r\n// 前端电商 sku 的全排列算法\r\n// 需求\r\n// 需求描述起来很简单，有这样三个数组：\r\n// let names = [\"iPhone X\", \"iPhone XS\"]\r\n\r\n// let colors = [\"黑色\", \"白色\"]\r\n\r\n// let storages = [\"64g\", \"256g\"]\r\n// 需要把他们的所有组合穷举出来，最终得到这样一个数组：\r\n// [\r\n//   [\"iPhone X\", \"黑色\", \"64g\"],\r\n//   [\"iPhone X\", \"黑色\", \"256g\"],\r\n//   [\"iPhone X\", \"白色\", \"64g\"],\r\n//   [\"iPhone X\", \"白色\", \"256g\"],\r\n//   [\"iPhone XS\", \"黑色\", \"64g\"],\r\n//   [\"iPhone XS\", \"黑色\", \"256g\"],\r\n//   [\"iPhone XS\", \"白色\", \"64g\"],\r\n//   [\"iPhone XS\", \"白色\", \"256g\"],\r\n// ]\r\n\r\nimport { useState, userEffect } from 'react';\r\nimport './style/index.css';\r\n\r\nexport default function Recursive2() {\r\n  //   const [showSort, setShowSort] = useState(false);\r\n  let names = ['iPhone X', 'iPhone XS'];\r\n\r\n  let colors = ['黑色', '白色'];\r\n\r\n  let storages = ['64g', '256g'];\r\n  // let size = ['6寸', '8寸', '10寸', '12寸'];\r\n  return (\r\n    <div>\r\n      <p\r\n        className=\"hoverClick subTitle\"\r\n        onClick={e => {\r\n          //   const result = runFunc([1, 2], [1, 2, 3]);\r\n          const result = runFunc(names, colors, storages);\r\n          console.log('🚀 ~ file: recursive2.js ~ line 40 ~ Recursive2 ~ result', result);\r\n        }}\r\n      >\r\n        前端电商 sku 的全排列算法 递归回溯算法\r\n      </p>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction runFunc(...args) {\r\n  window.runFunc = runFunc;\r\n  const result = [];\r\n  const length = args.length;\r\n\r\n  function runInnerFunc(start, prev) {\r\n    if (prev.length === length) {\r\n      result.push(prev);\r\n      return;\r\n    } else {\r\n      const thisArr = args[start];\r\n      for (let i = 0; i < thisArr.length; i++) {\r\n        runInnerFunc(start + 1, prev.concat(thisArr[i]));\r\n      }\r\n    }\r\n  }\r\n  runInnerFunc(0, []);\r\n  return result;\r\n}\r\n","F:\\projects\\blog\\src\\algorithms\\recursive\\nQueen.js",["115","116"],"//  递归回溯算法问题解析\r\n// n皇后问题\r\n// 问题\r\n// 先来看问题，其实问题不难理解：\r\n// n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\r\n\r\n// 上图为 8 皇后问题的一种解法。\r\n// 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。\r\n// 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。\r\n// 示例:\r\n// 输入: 4\r\n// 输出: [\r\n//  [\".Q..\",  // 解法 1\r\n//   \"...Q\",\r\n//   \"Q...\",\r\n//   \"..Q.\"],\r\n\r\n//  [\"..Q.\",  // 解法 2\r\n//   \"Q...\",\r\n//   \"...Q\",\r\n//   \".Q..\"]\r\n// ]\r\n// 解释: 4 皇后问题存在两个不同的解法。\r\n// 复制代码提示：\r\n\r\n// 皇后，是国际象棋中的棋子，意味着国王的妻子。皇后只做一件事，那就是“吃子”。当她遇见可以吃的棋子时，就迅速冲上去吃掉棋子。当然，她横、竖、斜都可走一到七步，可进可退。（引用自 百度百科 - 皇后 ）\r\n\r\nimport { useState, userEffect } from 'react';\r\nimport './style/index.css';\r\n\r\nexport default function nQueen() {\r\n  //   const [showSort, setShowSort] = useState(false);\r\n  return (\r\n    <div>\r\n      <p\r\n        className=\"hoverClick subTitle\"\r\n        onClick={e => {\r\n          //   const result = runFunc([1, 2], [1, 2, 3]);\r\n          const result = runFunc(4);\r\n          console.log('🚀 ~ file: nQueen.js ~ line 16 ~ Recursive2 ~ result', result);\r\n        }}\r\n      >\r\n        n皇后问题 递归回溯算法\r\n      </p>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction runFunc(n) {\r\n  window.runFunc = runFunc;\r\n  const result = [];\r\n  const columns = [];\r\n  const leftArc = [];\r\n  const rightArc = [];\r\n\r\n  function makeTable(arr) {\r\n    const res = [];\r\n    for (let i = 0; i < n; i++) {\r\n      let row = '';\r\n      for (let j = 0; j < n; j++) {\r\n        if (j === arr[i]) row += 'Q';\r\n        else row += '.';\r\n      }\r\n      res.push(row);\r\n    }\r\n    return res;\r\n  }\r\n\r\n  function placeItem(row, column, bool) {\r\n    columns[column] = bool;\r\n    leftArc[row + column] = bool;\r\n    rightArc[row - column] = bool;\r\n  }\r\n\r\n  function check(row, column) {\r\n    return !columns[column] && !leftArc[row + column] && !rightArc[row - column];\r\n  }\r\n\r\n  function runInnerFunc(start, prev) {\r\n    if (prev.length === n) {\r\n      result.push(makeTable(prev));\r\n      return;\r\n    } else {\r\n      for (let i = 0; i < n; i++) {\r\n        const isOk = check(start, i);\r\n        if (!isOk) continue;\r\n        placeItem(start, i, true);\r\n        runInnerFunc(start + 1, prev.concat(i));\r\n        placeItem(start, i, false);\r\n      }\r\n    }\r\n  }\r\n  runInnerFunc(0, []);\r\n  return result;\r\n}\r\n","F:\\projects\\blog\\src\\algorithms\\greedy\\greedy2.js",["117","118"],"// 贪心算法，盛最多水的容器\r\n// 题目描述\r\n// 给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。画 n 条垂直线，使得垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\r\n\r\n// 注意：你不能倾斜容器，n 至少是2。\r\n\r\n// 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\r\n\r\n// 示例:\r\n\r\n// 输入: [1,8,6,2,5,4,8,3,7]\r\n// 输出: 49\r\nimport { useState, userEffect } from 'react';\r\nimport './style/index.css';\r\n\r\nexport default function Greedy2() {\r\n  //   const [showSort, setShowSort] = useState(false);\r\n\r\n  return (\r\n    <div>\r\n      <p\r\n        className=\"hoverClick subTitle\"\r\n        onClick={e => {\r\n          const result = runFunc([1, 8, 6, 2, 5, 4, 8, 3, 7]);\r\n          console.log('🚀 ~ file: greedy2.js ~ line 25 ~ Greedy2 ~ result', result);\r\n        }}\r\n      >\r\n        盛最多水的容器， 双指针贪心算法\r\n      </p>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction runFunc(arr) {\r\n  window.runFunc = runFunc;\r\n  if (!arr) return 0;\r\n  if (arr.length <= 1) return 0;\r\n  let count = 0;\r\n  let left = 0;\r\n  let right = arr.length - 1;\r\n  while (left < right) {\r\n    count = Math.max(Math.min(arr[left], arr[right]) * (right - left), count);\r\n    if (arr[left] <= arr[right]) left++;\r\n    else right--;\r\n  }\r\n  return count;\r\n}\r\n","F:\\projects\\blog\\src\\algorithms\\map\\index.js",["119"],"F:\\projects\\blog\\src\\algorithms\\map\\map1.js",["120","121"],{"ruleId":"122","replacedBy":"123"},{"ruleId":"124","replacedBy":"125"},{"ruleId":"126","severity":1,"message":"127","line":1,"column":10,"nodeType":"128","messageId":"129","endLine":1,"endColumn":18},{"ruleId":"126","severity":1,"message":"130","line":1,"column":20,"nodeType":"128","messageId":"129","endLine":1,"endColumn":30},{"ruleId":"126","severity":1,"message":"127","line":32,"column":10,"nodeType":"128","messageId":"129","endLine":32,"endColumn":18},{"ruleId":"126","severity":1,"message":"130","line":32,"column":20,"nodeType":"128","messageId":"129","endLine":32,"endColumn":30},{"ruleId":"126","severity":1,"message":"130","line":3,"column":20,"nodeType":"128","messageId":"129","endLine":3,"endColumn":30},{"ruleId":"126","severity":1,"message":"127","line":45,"column":10,"nodeType":"128","messageId":"129","endLine":45,"endColumn":18},{"ruleId":"126","severity":1,"message":"130","line":45,"column":20,"nodeType":"128","messageId":"129","endLine":45,"endColumn":30},{"ruleId":"126","severity":1,"message":"131","line":80,"column":10,"nodeType":"128","messageId":"129","endLine":80,"endColumn":18},{"ruleId":"126","severity":1,"message":"130","line":3,"column":20,"nodeType":"128","messageId":"129","endLine":3,"endColumn":30},{"ruleId":"126","severity":1,"message":"127","line":41,"column":10,"nodeType":"128","messageId":"129","endLine":41,"endColumn":18},{"ruleId":"126","severity":1,"message":"130","line":41,"column":20,"nodeType":"128","messageId":"129","endLine":41,"endColumn":30},{"ruleId":"126","severity":1,"message":"130","line":1,"column":20,"nodeType":"128","messageId":"129","endLine":1,"endColumn":30},{"ruleId":"126","severity":1,"message":"132","line":13,"column":40,"nodeType":"128","messageId":"129","endLine":13,"endColumn":49},{"ruleId":"126","severity":1,"message":"133","line":1,"column":10,"nodeType":"128","messageId":"129","endLine":1,"endColumn":19},{"ruleId":"126","severity":1,"message":"130","line":1,"column":21,"nodeType":"128","messageId":"129","endLine":1,"endColumn":31},{"ruleId":"126","severity":1,"message":"134","line":4,"column":7,"nodeType":"128","messageId":"129","endLine":4,"endColumn":17},{"ruleId":"126","severity":1,"message":"130","line":1,"column":20,"nodeType":"128","messageId":"129","endLine":1,"endColumn":30},{"ruleId":"126","severity":1,"message":"127","line":18,"column":10,"nodeType":"128","messageId":"129","endLine":18,"endColumn":18},{"ruleId":"126","severity":1,"message":"130","line":18,"column":20,"nodeType":"128","messageId":"129","endLine":18,"endColumn":30},{"ruleId":"126","severity":1,"message":"127","line":22,"column":10,"nodeType":"128","messageId":"129","endLine":22,"endColumn":18},{"ruleId":"126","severity":1,"message":"130","line":22,"column":20,"nodeType":"128","messageId":"129","endLine":22,"endColumn":30},{"ruleId":"126","severity":1,"message":"127","line":28,"column":10,"nodeType":"128","messageId":"129","endLine":28,"endColumn":18},{"ruleId":"126","severity":1,"message":"130","line":28,"column":20,"nodeType":"128","messageId":"129","endLine":28,"endColumn":30},{"ruleId":"126","severity":1,"message":"127","line":13,"column":10,"nodeType":"128","messageId":"129","endLine":13,"endColumn":18},{"ruleId":"126","severity":1,"message":"130","line":13,"column":20,"nodeType":"128","messageId":"129","endLine":13,"endColumn":30},{"ruleId":"126","severity":1,"message":"130","line":3,"column":20,"nodeType":"128","messageId":"129","endLine":3,"endColumn":30},{"ruleId":"126","severity":1,"message":"127","line":14,"column":10,"nodeType":"128","messageId":"129","endLine":14,"endColumn":18},{"ruleId":"126","severity":1,"message":"130","line":14,"column":20,"nodeType":"128","messageId":"129","endLine":14,"endColumn":30},"no-native-reassign",["135"],"no-negated-in-lhs",["136"],"no-unused-vars","'useState' is defined but never used.","Identifier","unusedVar","'userEffect' is defined but never used.","'runFunc2' is defined but never used.","'quickSort' is assigned a value but never used.","'userState' is defined but never used.","'insertSort' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]